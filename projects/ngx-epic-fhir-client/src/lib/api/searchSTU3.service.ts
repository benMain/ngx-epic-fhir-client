/**
 * Epic on Fhir
 * All of the components of the Change Healthcare Interoperability Apis
 *
 * OpenAPI spec version: 1.0.0
 * Contact: bmain@lumeris.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
} from '@angular/common/http';
import { CustomHttpUrlEncodingCodec } from '../encoder';

import { Observable } from 'rxjs';

import { BundleAllergyIntoleranceSTU3 } from '../model/bundleAllergyIntoleranceSTU3';
import { BundleAppointmentSTU3 } from '../model/bundleAppointmentSTU3';
import { BundleCoverageSTU3 } from '../model/bundleCoverageSTU3';
import { BundleDeviceRequestSTU3 } from '../model/bundleDeviceRequestSTU3';
import { BundleEncounterSTU3 } from '../model/bundleEncounterSTU3';
import { BundleImmunizationRecommendationSTU3 } from '../model/bundleImmunizationRecommendationSTU3';
import { BundleImmunizationSTU3 } from '../model/bundleImmunizationSTU3';
import { BundleMedicationStatementSTU3 } from '../model/bundleMedicationStatementSTU3';
import { BundleNutritionOrderSTU3 } from '../model/bundleNutritionOrderSTU3';
import { BundlePatientSTU3 } from '../model/bundlePatientSTU3';
import { BundlePractitionerRoleSTU3 } from '../model/bundlePractitionerRoleSTU3';
import { BundlePractitionerSTU3 } from '../model/bundlePractitionerSTU3';
import { BundleSpecimenSTU3 } from '../model/bundleSpecimenSTU3';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

@Injectable()
export class SearchSTU3Service {
  protected basePath = 'https://fhir.epic.com/interconnect-fhir-oauth/api/FHIR';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string,
    @Optional() configuration: Configuration
  ) {
    if (basePath) {
      this.basePath = basePath;
    }
    if (configuration) {
      this.configuration = configuration;
      this.basePath = basePath || configuration.basePath || this.basePath;
    }
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (const consume of consumes) {
      if (form === consume) {
        return true;
      }
    }
    return false;
  }

  /**
   *
   *
   * @param patient Reference to a patient resource.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public allergyIntoleranceSearchSTU3(
    patient: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleAllergyIntoleranceSTU3>;
  public allergyIntoleranceSearchSTU3(
    patient: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleAllergyIntoleranceSTU3>>;
  public allergyIntoleranceSearchSTU3(
    patient: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleAllergyIntoleranceSTU3>>;
  public allergyIntoleranceSearchSTU3(
    patient: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (patient === null || patient === undefined) {
      throw new Error(
        'Required parameter patient was null or undefined when calling allergyIntoleranceSearchSTU3.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleAllergyIntoleranceSTU3>(
      'get',
      `${this.basePath}/STU3/AllergyIntolerance`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param patient Reference to the Patient resource.
   * @param date Appointment date.
   * @param identifier Appointment identifier (encounter CSN).
   * @param status Appointment status. Supported values include: &lt;ul&gt; &lt;li&gt;booked&lt;/li&gt; &lt;li&gt;fulfilled&lt;/li&gt; &lt;li&gt;cancelled&lt;/li&gt; &lt;li&gt;noshow&lt;/li&gt; &lt;li&gt;arrived&lt;/li&gt; &lt;li&gt;proposed&lt;/li&gt; &lt;/ul&gt;
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public appointmentSearchSTU3(
    patient: string,
    date?: string,
    identifier?: string,
    status?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleAppointmentSTU3>;
  public appointmentSearchSTU3(
    patient: string,
    date?: string,
    identifier?: string,
    status?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleAppointmentSTU3>>;
  public appointmentSearchSTU3(
    patient: string,
    date?: string,
    identifier?: string,
    status?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleAppointmentSTU3>>;
  public appointmentSearchSTU3(
    patient: string,
    date?: string,
    identifier?: string,
    status?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (patient === null || patient === undefined) {
      throw new Error(
        'Required parameter patient was null or undefined when calling appointmentSearchSTU3.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (date !== undefined && date !== null) {
      queryParameters = queryParameters.set('date', <any>date);
    }
    if (identifier !== undefined && identifier !== null) {
      queryParameters = queryParameters.set('identifier', <any>identifier);
    }
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }
    if (status !== undefined && status !== null) {
      queryParameters = queryParameters.set('status', <any>status);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleAppointmentSTU3>(
      'get',
      `${this.basePath}/STU3/Appointment`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param beneficiary &lt;p&gt;Either the beneficiary or the patient must be specified in the search request. If both are specified, they must match.&lt;/p&gt;
   * @param patient &lt;p&gt;Either the beneficiary or the patient must be specified in the search request. If both are specified, they must match.&lt;/p&gt;
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public coverageSearchSTU3(
    beneficiary: string,
    patient: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleCoverageSTU3>;
  public coverageSearchSTU3(
    beneficiary: string,
    patient: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleCoverageSTU3>>;
  public coverageSearchSTU3(
    beneficiary: string,
    patient: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleCoverageSTU3>>;
  public coverageSearchSTU3(
    beneficiary: string,
    patient: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (beneficiary === null || beneficiary === undefined) {
      throw new Error(
        'Required parameter beneficiary was null or undefined when calling coverageSearchSTU3.'
      );
    }

    if (patient === null || patient === undefined) {
      throw new Error(
        'Required parameter patient was null or undefined when calling coverageSearchSTU3.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (beneficiary !== undefined && beneficiary !== null) {
      queryParameters = queryParameters.set('beneficiary', <any>beneficiary);
    }
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleCoverageSTU3>(
      'get',
      `${this.basePath}/STU3/Coverage`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param patient &lt;p&gt;Patient identifier for the patient who is the target of the request&lt;/p&gt; &lt;p&gt;This property is always required by Epic.&lt;/p&gt;
   * @param status &lt;p&gt;The status of a request. Can be one of the following:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;active&lt;/li&gt; &lt;li&gt;completed&lt;/li&gt; &lt;li&gt;draft&lt;/li&gt; &lt;li&gt;cancelled&lt;/li&gt; &lt;li&gt;unknown&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If unspecified, returns requests of all statuses.&lt;/p&gt;
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deviceRequestSearchSTU3(
    patient: string,
    status?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleDeviceRequestSTU3>;
  public deviceRequestSearchSTU3(
    patient: string,
    status?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleDeviceRequestSTU3>>;
  public deviceRequestSearchSTU3(
    patient: string,
    status?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleDeviceRequestSTU3>>;
  public deviceRequestSearchSTU3(
    patient: string,
    status?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (patient === null || patient === undefined) {
      throw new Error(
        'Required parameter patient was null or undefined when calling deviceRequestSearchSTU3.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }
    if (status !== undefined && status !== null) {
      queryParameters = queryParameters.set('status', <any>status);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleDeviceRequestSTU3>(
      'get',
      `${this.basePath}/STU3/DeviceRequest`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param identifier &lt;p&gt;Identifiers by which this encounter is known in the format &amp;lt;code system&amp;gt;|&amp;lt;code&amp;gt;.&lt;/p&gt; &lt;p&gt;This search parameter is available starting in the August 2021 version of Epic.&lt;/p&gt;
   * @param _class Classification of patient encounter. For organizations in the Netherlands, this element includes only the ACT encounter code.
   * @param date A date range that the encounter takes place.
   * @param patient Reference to a patient resource.
   * @param subject Reference to a patient resource.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public encounterSearchSTU3(
    identifier: string,
    _class?: string,
    date?: string,
    patient?: string,
    subject?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleEncounterSTU3>;
  public encounterSearchSTU3(
    identifier: string,
    _class?: string,
    date?: string,
    patient?: string,
    subject?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleEncounterSTU3>>;
  public encounterSearchSTU3(
    identifier: string,
    _class?: string,
    date?: string,
    patient?: string,
    subject?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleEncounterSTU3>>;
  public encounterSearchSTU3(
    identifier: string,
    _class?: string,
    date?: string,
    patient?: string,
    subject?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (identifier === null || identifier === undefined) {
      throw new Error(
        'Required parameter identifier was null or undefined when calling encounterSearchSTU3.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (_class !== undefined && _class !== null) {
      queryParameters = queryParameters.set('class', <any>_class);
    }
    if (date !== undefined && date !== null) {
      queryParameters = queryParameters.set('date', <any>date);
    }
    if (identifier !== undefined && identifier !== null) {
      queryParameters = queryParameters.set('identifier', <any>identifier);
    }
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }
    if (subject !== undefined && subject !== null) {
      queryParameters = queryParameters.set('subject', <any>subject);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleEncounterSTU3>(
      'get',
      `${this.basePath}/STU3/Encounter`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param patient The patient associated with the immunization recommendation. Reference to the Patient resource.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public immunizationRecommendationSearchSTU3(
    patient: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleImmunizationRecommendationSTU3>;
  public immunizationRecommendationSearchSTU3(
    patient: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleImmunizationRecommendationSTU3>>;
  public immunizationRecommendationSearchSTU3(
    patient: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleImmunizationRecommendationSTU3>>;
  public immunizationRecommendationSearchSTU3(
    patient: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (patient === null || patient === undefined) {
      throw new Error(
        'Required parameter patient was null or undefined when calling immunizationRecommendationSearchSTU3.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleImmunizationRecommendationSTU3>(
      'get',
      `${this.basePath}/STU3/ImmunizationRecommendation`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param patient Reference to the Patient who was immunized.
   * @param date Vaccination administration date.
   * @param notgiven Flag for whether the immunization was given. If not provided, defaults to \&quot;false\&quot; to return only given immunizations.
   * @param status &lt;p&gt;Immunization event status. “Completed” is the only supported value, and this value is used by default if no status value is specified.&lt;/p&gt;
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public immunizationSearchSTU3(
    patient: string,
    date?: string,
    notgiven?: string,
    status?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleImmunizationSTU3>;
  public immunizationSearchSTU3(
    patient: string,
    date?: string,
    notgiven?: string,
    status?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleImmunizationSTU3>>;
  public immunizationSearchSTU3(
    patient: string,
    date?: string,
    notgiven?: string,
    status?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleImmunizationSTU3>>;
  public immunizationSearchSTU3(
    patient: string,
    date?: string,
    notgiven?: string,
    status?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (patient === null || patient === undefined) {
      throw new Error(
        'Required parameter patient was null or undefined when calling immunizationSearchSTU3.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (date !== undefined && date !== null) {
      queryParameters = queryParameters.set('date', <any>date);
    }
    if (notgiven !== undefined && notgiven !== null) {
      queryParameters = queryParameters.set('notgiven', <any>notgiven);
    }
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }
    if (status !== undefined && status !== null) {
      queryParameters = queryParameters.set('status', <any>status);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleImmunizationSTU3>(
      'get',
      `${this.basePath}/STU3/Immunization`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param patient The FHIR Patient ID. Either this element or Subject is required.
   * @param subject The FHIR patient ID. Either this element or Patient is required.
   * @param category &lt;p&gt;The category of medication orders to search for. By default all categories are searched.&lt;/p&gt;  Supported categories: &lt;ul&gt; &lt;li&gt;inpatient&lt;/li&gt; &lt;li&gt;outpatient&lt;/li&gt; &lt;li&gt;community&lt;/li&gt; &lt;li&gt;patientspecified&lt;/li&gt;  &lt;p&gt;Starting in February 2022 or November 2021 with special update, organizations in the Netherlands can use the code 6 to search for MedicationUse profiles.&lt;/p&gt;
   * @param effective Date when patient was taking (or not taking) the medication.
   * @param status &lt;p&gt;The status for medication orders. By default, active is assumed. Active must be present in all searches (i.e. you cannot search for just completed meds).&lt;/p&gt;  Supported statuses: &lt;ul&gt; &lt;li&gt;On-hold&lt;/li&gt; &lt;li&gt;Completed&lt;/li&gt; &lt;li&gt;Stopped&lt;/li&gt; &lt;li&gt;Active&lt;/li&gt;
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public medicationStatementSearchSTU3(
    patient: string,
    subject: string,
    category?: string,
    effective?: string,
    status?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleMedicationStatementSTU3>;
  public medicationStatementSearchSTU3(
    patient: string,
    subject: string,
    category?: string,
    effective?: string,
    status?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleMedicationStatementSTU3>>;
  public medicationStatementSearchSTU3(
    patient: string,
    subject: string,
    category?: string,
    effective?: string,
    status?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleMedicationStatementSTU3>>;
  public medicationStatementSearchSTU3(
    patient: string,
    subject: string,
    category?: string,
    effective?: string,
    status?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (patient === null || patient === undefined) {
      throw new Error(
        'Required parameter patient was null or undefined when calling medicationStatementSearchSTU3.'
      );
    }

    if (subject === null || subject === undefined) {
      throw new Error(
        'Required parameter subject was null or undefined when calling medicationStatementSearchSTU3.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (category !== undefined && category !== null) {
      queryParameters = queryParameters.set('category', <any>category);
    }
    if (effective !== undefined && effective !== null) {
      queryParameters = queryParameters.set('effective', <any>effective);
    }
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }
    if (status !== undefined && status !== null) {
      queryParameters = queryParameters.set('status', <any>status);
    }
    if (subject !== undefined && subject !== null) {
      queryParameters = queryParameters.set('subject', <any>subject);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleMedicationStatementSTU3>(
      'get',
      `${this.basePath}/STU3/MedicationStatement`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param patient FHIR identifier for the patient whose nutrition order details are being requested.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public nutritionOrderSearchSTU3(
    patient: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleNutritionOrderSTU3>;
  public nutritionOrderSearchSTU3(
    patient: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleNutritionOrderSTU3>>;
  public nutritionOrderSearchSTU3(
    patient: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleNutritionOrderSTU3>>;
  public nutritionOrderSearchSTU3(
    patient: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (patient === null || patient === undefined) {
      throw new Error(
        'Required parameter patient was null or undefined when calling nutritionOrderSearchSTU3.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleNutritionOrderSTU3>(
      'get',
      `${this.basePath}/STU3/NutritionOrder`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param address The patient&#x27;s street address.
   * @param addressCity The city for patient&#x27;s home address.
   * @param addressPostalcode The postal code for patient&#x27;s home address.
   * @param addressState The state for the patient&#x27;s home address.
   * @param birthdate The patient&#x27;s date of birth in the format YYYY-MM-DD.
   * @param family The patient&#x27;s family (last) name.
   * @param gender The patient&#x27;s legal sex. Starting in the August 2021 version of Epic, the legal-sex parameter is preferred.
   * @param given The patient&#x27;s given name. May include first and middle names.
   * @param identifier &lt;p&gt;The patient&#x27;s identifier.&lt;/p&gt;  &lt;p&gt;This web service supports using ID and ID type combinations, such as Patient?identifier&#x3D;MRN|202497.&lt;/p&gt;
   * @param legalSex The patient’s legal sex. Takes precedence over the gender search parameter.   Available starting in the August 2021 version of Epic.
   * @param ownName The patient&#x27;s own last name. Usually used in non-US names.
   * @param ownPrefix The patient&#x27;s own prefix. Usually used in non-US names.
   * @param partnerName The patient&#x27;s spouse&#x27;s last name. Usually used in non-US names.
   * @param partnerPrefix The patient&#x27;s spouse&#x27;s prefix. Usually used in non-US names.
   * @param telecom The patient&#x27;s phone number or email.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public patientSearchSTU3(
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    birthdate?: string,
    family?: string,
    gender?: string,
    given?: string,
    identifier?: string,
    legalSex?: string,
    ownName?: string,
    ownPrefix?: string,
    partnerName?: string,
    partnerPrefix?: string,
    telecom?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundlePatientSTU3>;
  public patientSearchSTU3(
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    birthdate?: string,
    family?: string,
    gender?: string,
    given?: string,
    identifier?: string,
    legalSex?: string,
    ownName?: string,
    ownPrefix?: string,
    partnerName?: string,
    partnerPrefix?: string,
    telecom?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundlePatientSTU3>>;
  public patientSearchSTU3(
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    birthdate?: string,
    family?: string,
    gender?: string,
    given?: string,
    identifier?: string,
    legalSex?: string,
    ownName?: string,
    ownPrefix?: string,
    partnerName?: string,
    partnerPrefix?: string,
    telecom?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundlePatientSTU3>>;
  public patientSearchSTU3(
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    birthdate?: string,
    family?: string,
    gender?: string,
    given?: string,
    identifier?: string,
    legalSex?: string,
    ownName?: string,
    ownPrefix?: string,
    partnerName?: string,
    partnerPrefix?: string,
    telecom?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (address !== undefined && address !== null) {
      queryParameters = queryParameters.set('address', <any>address);
    }
    if (addressCity !== undefined && addressCity !== null) {
      queryParameters = queryParameters.set('address-city', <any>addressCity);
    }
    if (addressPostalcode !== undefined && addressPostalcode !== null) {
      queryParameters = queryParameters.set(
        'address-postalcode',
        <any>addressPostalcode
      );
    }
    if (addressState !== undefined && addressState !== null) {
      queryParameters = queryParameters.set('address-state', <any>addressState);
    }
    if (birthdate !== undefined && birthdate !== null) {
      queryParameters = queryParameters.set('birthdate', <any>birthdate);
    }
    if (family !== undefined && family !== null) {
      queryParameters = queryParameters.set('family', <any>family);
    }
    if (gender !== undefined && gender !== null) {
      queryParameters = queryParameters.set('gender', <any>gender);
    }
    if (given !== undefined && given !== null) {
      queryParameters = queryParameters.set('given', <any>given);
    }
    if (identifier !== undefined && identifier !== null) {
      queryParameters = queryParameters.set('identifier', <any>identifier);
    }
    if (legalSex !== undefined && legalSex !== null) {
      queryParameters = queryParameters.set('legal-sex', <any>legalSex);
    }
    if (ownName !== undefined && ownName !== null) {
      queryParameters = queryParameters.set('own-name', <any>ownName);
    }
    if (ownPrefix !== undefined && ownPrefix !== null) {
      queryParameters = queryParameters.set('own-prefix', <any>ownPrefix);
    }
    if (partnerName !== undefined && partnerName !== null) {
      queryParameters = queryParameters.set('partner-name', <any>partnerName);
    }
    if (partnerPrefix !== undefined && partnerPrefix !== null) {
      queryParameters = queryParameters.set(
        'partner-prefix',
        <any>partnerPrefix
      );
    }
    if (telecom !== undefined && telecom !== null) {
      queryParameters = queryParameters.set('telecom', <any>telecom);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundlePatientSTU3>(
      'get',
      `${this.basePath}/STU3/Patient`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param email Value in an email contact.
   * @param identifier A practitioner&#x27;s identifier. A successful identifier search comprises of a token that is a URN:OID: + the code system, and a code in the format identifier&#x3D;code system|code.
   * @param location One of the locations at which this practitioner provides care.
   * @param organization The organization that the practitioner represents or acts on behalf of.
   * @param phone A value in a phone contact.
   * @param practitioner A practitioner that can provide the defined services for the organization.
   * @param role The role a practitioner can perform at an organization.
   * @param specialty The practitioner&#x27;s specialty at an organization.
   * @param telecom The value in any kind of contact.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public practitionerRoleSearchSTU3(
    email?: string,
    identifier?: string,
    location?: string,
    organization?: string,
    phone?: string,
    practitioner?: string,
    role?: string,
    specialty?: string,
    telecom?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundlePractitionerRoleSTU3>;
  public practitionerRoleSearchSTU3(
    email?: string,
    identifier?: string,
    location?: string,
    organization?: string,
    phone?: string,
    practitioner?: string,
    role?: string,
    specialty?: string,
    telecom?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundlePractitionerRoleSTU3>>;
  public practitionerRoleSearchSTU3(
    email?: string,
    identifier?: string,
    location?: string,
    organization?: string,
    phone?: string,
    practitioner?: string,
    role?: string,
    specialty?: string,
    telecom?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundlePractitionerRoleSTU3>>;
  public practitionerRoleSearchSTU3(
    email?: string,
    identifier?: string,
    location?: string,
    organization?: string,
    phone?: string,
    practitioner?: string,
    role?: string,
    specialty?: string,
    telecom?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (email !== undefined && email !== null) {
      queryParameters = queryParameters.set('email', <any>email);
    }
    if (identifier !== undefined && identifier !== null) {
      queryParameters = queryParameters.set('identifier', <any>identifier);
    }
    if (location !== undefined && location !== null) {
      queryParameters = queryParameters.set('location', <any>location);
    }
    if (organization !== undefined && organization !== null) {
      queryParameters = queryParameters.set('organization', <any>organization);
    }
    if (phone !== undefined && phone !== null) {
      queryParameters = queryParameters.set('phone', <any>phone);
    }
    if (practitioner !== undefined && practitioner !== null) {
      queryParameters = queryParameters.set('practitioner', <any>practitioner);
    }
    if (role !== undefined && role !== null) {
      queryParameters = queryParameters.set('role', <any>role);
    }
    if (specialty !== undefined && specialty !== null) {
      queryParameters = queryParameters.set('specialty', <any>specialty);
    }
    if (telecom !== undefined && telecom !== null) {
      queryParameters = queryParameters.set('telecom', <any>telecom);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundlePractitionerRoleSTU3>(
      'get',
      `${this.basePath}/STU3/PractitionerRole`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param family A portion of the family name. If name or identifier is provided, this is not required.
   * @param identifier &lt;p&gt;A practitioner&#x27;s identifier, such as NPI. If Family or Name is provided, this is not required.&lt;/p&gt;  &lt;p&gt;Starting in November 2018, this web service supports using ID and ID type combinations, such as Practitioner?identifier&#x3D;External|802559.&lt;/p&gt;
   * @param name Free text that can match either Family or Given (or both). If Family or Identifier is provided, this is not required.
   * @param address The free-text address.
   * @param addressCity The city specified in the address. City cannot be specified without state or ZIP code.
   * @param addressPostalcode A ZIP code specified in the address.
   * @param addressState A state specified in the address.
   * @param given A portion of the given name. If Given is provided, Family must also be provided.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public practitionerSearchSTU3(
    family: string,
    identifier: string,
    name: string,
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    given?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundlePractitionerSTU3>;
  public practitionerSearchSTU3(
    family: string,
    identifier: string,
    name: string,
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    given?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundlePractitionerSTU3>>;
  public practitionerSearchSTU3(
    family: string,
    identifier: string,
    name: string,
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    given?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundlePractitionerSTU3>>;
  public practitionerSearchSTU3(
    family: string,
    identifier: string,
    name: string,
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    given?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (family === null || family === undefined) {
      throw new Error(
        'Required parameter family was null or undefined when calling practitionerSearchSTU3.'
      );
    }

    if (identifier === null || identifier === undefined) {
      throw new Error(
        'Required parameter identifier was null or undefined when calling practitionerSearchSTU3.'
      );
    }

    if (name === null || name === undefined) {
      throw new Error(
        'Required parameter name was null or undefined when calling practitionerSearchSTU3.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (address !== undefined && address !== null) {
      queryParameters = queryParameters.set('address', <any>address);
    }
    if (addressCity !== undefined && addressCity !== null) {
      queryParameters = queryParameters.set('address-city', <any>addressCity);
    }
    if (addressPostalcode !== undefined && addressPostalcode !== null) {
      queryParameters = queryParameters.set(
        'address-postalcode',
        <any>addressPostalcode
      );
    }
    if (addressState !== undefined && addressState !== null) {
      queryParameters = queryParameters.set('address-state', <any>addressState);
    }
    if (family !== undefined && family !== null) {
      queryParameters = queryParameters.set('family', <any>family);
    }
    if (given !== undefined && given !== null) {
      queryParameters = queryParameters.set('given', <any>given);
    }
    if (identifier !== undefined && identifier !== null) {
      queryParameters = queryParameters.set('identifier', <any>identifier);
    }
    if (name !== undefined && name !== null) {
      queryParameters = queryParameters.set('name', <any>name);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundlePractitionerSTU3>(
      'get',
      `${this.basePath}/STU3/Practitioner`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public specimenSearchSTU3(
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleSpecimenSTU3>;
  public specimenSearchSTU3(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleSpecimenSTU3>>;
  public specimenSearchSTU3(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleSpecimenSTU3>>;
  public specimenSearchSTU3(
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleSpecimenSTU3>(
      'get',
      `${this.basePath}/STU3/Specimen`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }
}
