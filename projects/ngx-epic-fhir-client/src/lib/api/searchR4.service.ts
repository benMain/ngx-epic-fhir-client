/**
 * Epic on Fhir
 * All of the components of the Change Healthcare Interoperability Apis
 *
 * OpenAPI spec version: 1.0.0
 * Contact: bmain@lumeris.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
} from '@angular/common/http';
import { CustomHttpUrlEncodingCodec } from '../encoder';

import { Observable } from 'rxjs';

import { BundleAdverseEventR4 } from '../model/bundleAdverseEventR4';
import { BundleAllergyIntoleranceR4 } from '../model/bundleAllergyIntoleranceR4';
import { BundleCoverageR4 } from '../model/bundleCoverageR4';
import { BundleDeviceRequestR4 } from '../model/bundleDeviceRequestR4';
import { BundleEncounterR4 } from '../model/bundleEncounterR4';
import { BundleExplanationOfBenefitR4 } from '../model/bundleExplanationOfBenefitR4';
import { BundleImmunizationR4 } from '../model/bundleImmunizationR4';
import { BundleImmunizationRecommendationR4 } from '../model/bundleImmunizationRecommendationR4';
import { BundleLocationR4 } from '../model/bundleLocationR4';
import { BundleMedicationR4 } from '../model/bundleMedicationR4';
import { BundleNutritionOrderR4 } from '../model/bundleNutritionOrderR4';
import { BundleOrganizationR4 } from '../model/bundleOrganizationR4';
import { BundlePatientR4 } from '../model/bundlePatientR4';
import { BundlePractitionerR4 } from '../model/bundlePractitionerR4';
import { BundlePractitionerRoleR4 } from '../model/bundlePractitionerRoleR4';
import { BundleResearchStudyR4 } from '../model/bundleResearchStudyR4';
import { BundleSpecimenR4 } from '../model/bundleSpecimenR4';
import { BundleSubstanceR4 } from '../model/bundleSubstanceR4';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

@Injectable()
export class SearchR4Service {
  protected basePath = 'https://fhir.epic.com/interconnect-fhir-oauth/api/FHIR';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string,
    @Optional() configuration: Configuration
  ) {
    if (basePath) {
      this.basePath = basePath;
    }
    if (configuration) {
      this.configuration = configuration;
      this.basePath = basePath || configuration.basePath || this.basePath;
    }
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (const consume of consumes) {
      if (form === consume) {
        return true;
      }
    }
    return false;
  }

  /**
   *
   *
   * @param study A ResearchStudy FHIR ID.
   * @param subject A Patient FHIR ID.
   * @param seriousness &lt;p&gt;Seriousness of the event. Possible values are:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Serious&lt;/li&gt; &lt;li&gt;Non-Serious&lt;/li&gt; &lt;/ul&gt;
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public adverseEventSearchR4(
    study: string,
    subject: string,
    seriousness?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleAdverseEventR4>;
  public adverseEventSearchR4(
    study: string,
    subject: string,
    seriousness?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleAdverseEventR4>>;
  public adverseEventSearchR4(
    study: string,
    subject: string,
    seriousness?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleAdverseEventR4>>;
  public adverseEventSearchR4(
    study: string,
    subject: string,
    seriousness?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (study === null || study === undefined) {
      throw new Error(
        'Required parameter study was null or undefined when calling adverseEventSearchR4.'
      );
    }

    if (subject === null || subject === undefined) {
      throw new Error(
        'Required parameter subject was null or undefined when calling adverseEventSearchR4.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (seriousness !== undefined && seriousness !== null) {
      queryParameters = queryParameters.set('seriousness', <any>seriousness);
    }
    if (study !== undefined && study !== null) {
      queryParameters = queryParameters.set('study', <any>study);
    }
    if (subject !== undefined && subject !== null) {
      queryParameters = queryParameters.set('subject', <any>subject);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleAdverseEventR4>(
      'get',
      `${this.basePath}/R4/AdverseEvent`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param patient Reference to a patient resource.
   * @param clinicalStatus &lt;p&gt;The current status of the allergy. Only \&quot;active\&quot; is accepted. &lt;p&gt;Starting in the August 2021 version of Epic, this parameter is no longer required, and if is not specified, both active and inactive/resolved allergies are returned.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public allergyIntoleranceSearchR4(
    patient: string,
    clinicalStatus?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleAllergyIntoleranceR4>;
  public allergyIntoleranceSearchR4(
    patient: string,
    clinicalStatus?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleAllergyIntoleranceR4>>;
  public allergyIntoleranceSearchR4(
    patient: string,
    clinicalStatus?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleAllergyIntoleranceR4>>;
  public allergyIntoleranceSearchR4(
    patient: string,
    clinicalStatus?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (patient === null || patient === undefined) {
      throw new Error(
        'Required parameter patient was null or undefined when calling allergyIntoleranceSearchR4.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (clinicalStatus !== undefined && clinicalStatus !== null) {
      queryParameters = queryParameters.set(
        'clinical-status',
        <any>clinicalStatus
      );
    }
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleAllergyIntoleranceR4>(
      'get',
      `${this.basePath}/R4/AllergyIntolerance`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param beneficiary &lt;p&gt;Either the beneficiary or the patient must be specified in the search request. If both are specified, they must match.&lt;/p&gt;
   * @param patient &lt;p&gt;Either the beneficiary or the patient must be specified in the search request. If both are specified, they must match.&lt;/p&gt;
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public coverageSearchR4(
    beneficiary: string,
    patient: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleCoverageR4>;
  public coverageSearchR4(
    beneficiary: string,
    patient: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleCoverageR4>>;
  public coverageSearchR4(
    beneficiary: string,
    patient: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleCoverageR4>>;
  public coverageSearchR4(
    beneficiary: string,
    patient: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (beneficiary === null || beneficiary === undefined) {
      throw new Error(
        'Required parameter beneficiary was null or undefined when calling coverageSearchR4.'
      );
    }

    if (patient === null || patient === undefined) {
      throw new Error(
        'Required parameter patient was null or undefined when calling coverageSearchR4.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (beneficiary !== undefined && beneficiary !== null) {
      queryParameters = queryParameters.set('beneficiary', <any>beneficiary);
    }
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleCoverageR4>(
      'get',
      `${this.basePath}/R4/Coverage`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param patient &lt;p&gt;Patient identifier for the patient who is the target of the request&lt;/p&gt; &lt;p&gt;This property is always required by Epic.&lt;/p&gt;
   * @param status &lt;p&gt;The status of a request. Can be one of the following:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;active&lt;/li&gt; &lt;li&gt;completed&lt;/li&gt; &lt;li&gt;draft&lt;/li&gt; &lt;li&gt;cancelled&lt;/li&gt; &lt;li&gt;unknown&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If unspecified, returns requests of all statuses.&lt;/p&gt;
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deviceRequestSearchR4(
    patient: string,
    status?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleDeviceRequestR4>;
  public deviceRequestSearchR4(
    patient: string,
    status?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleDeviceRequestR4>>;
  public deviceRequestSearchR4(
    patient: string,
    status?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleDeviceRequestR4>>;
  public deviceRequestSearchR4(
    patient: string,
    status?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (patient === null || patient === undefined) {
      throw new Error(
        'Required parameter patient was null or undefined when calling deviceRequestSearchR4.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }
    if (status !== undefined && status !== null) {
      queryParameters = queryParameters.set('status', <any>status);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleDeviceRequestR4>(
      'get',
      `${this.basePath}/R4/DeviceRequest`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param _class Classification of patient encounter. For organizations in the Netherlands, this element includes only the ACT encounter code.
   * @param date A date range that the encounter takes place.
   * @param identifier &lt;p&gt;Identifiers by which this encounter is known in the format &amp;lt;code system&amp;gt;|&amp;lt;code&amp;gt;.&lt;/p&gt; &lt;p&gt;This search parameter is available starting in the August 2021 version of Epic.&lt;/p&gt;
   * @param onlyscannable If \&quot;true\&quot;, only scannable encounters are returned in the response. This feature requires a user to have login department context as part of the API request, otherwise error code 59100 is returned.
   * @param patient Reference to a patient resource.
   * @param subject Reference to a patient resource.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public encounterSearchR4(
    _class: string,
    date: string,
    identifier: string,
    onlyscannable: string,
    patient?: string,
    subject?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleEncounterR4>;
  public encounterSearchR4(
    _class: string,
    date: string,
    identifier: string,
    onlyscannable: string,
    patient?: string,
    subject?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleEncounterR4>>;
  public encounterSearchR4(
    _class: string,
    date: string,
    identifier: string,
    onlyscannable: string,
    patient?: string,
    subject?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleEncounterR4>>;
  public encounterSearchR4(
    _class: string,
    date: string,
    identifier: string,
    onlyscannable: string,
    patient?: string,
    subject?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (_class === null || _class === undefined) {
      throw new Error(
        'Required parameter _class was null or undefined when calling encounterSearchR4.'
      );
    }

    if (date === null || date === undefined) {
      throw new Error(
        'Required parameter date was null or undefined when calling encounterSearchR4.'
      );
    }

    if (identifier === null || identifier === undefined) {
      throw new Error(
        'Required parameter identifier was null or undefined when calling encounterSearchR4.'
      );
    }

    if (onlyscannable === null || onlyscannable === undefined) {
      throw new Error(
        'Required parameter onlyscannable was null or undefined when calling encounterSearchR4.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (_class !== undefined && _class !== null) {
      queryParameters = queryParameters.set('class', <any>_class);
    }
    if (date !== undefined && date !== null) {
      queryParameters = queryParameters.set('date', <any>date);
    }
    if (identifier !== undefined && identifier !== null) {
      queryParameters = queryParameters.set('identifier', <any>identifier);
    }
    if (onlyscannable !== undefined && onlyscannable !== null) {
      queryParameters = queryParameters.set(
        'onlyscannable',
        <any>onlyscannable
      );
    }
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }
    if (subject !== undefined && subject !== null) {
      queryParameters = queryParameters.set('subject', <any>subject);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleEncounterR4>(
      'get',
      `${this.basePath}/R4/Encounter`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param patient The patient for whom claims data is being retrieved.
   * @param created Creation date of the claim.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public explanationOfBenefitSearchR4(
    patient: string,
    created?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleExplanationOfBenefitR4>;
  public explanationOfBenefitSearchR4(
    patient: string,
    created?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleExplanationOfBenefitR4>>;
  public explanationOfBenefitSearchR4(
    patient: string,
    created?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleExplanationOfBenefitR4>>;
  public explanationOfBenefitSearchR4(
    patient: string,
    created?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (patient === null || patient === undefined) {
      throw new Error(
        'Required parameter patient was null or undefined when calling explanationOfBenefitSearchR4.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (created !== undefined && created !== null) {
      queryParameters = queryParameters.set('created', <any>created);
    }
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleExplanationOfBenefitR4>(
      'get',
      `${this.basePath}/R4/ExplanationOfBenefit`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param patient The patient associated with the immunization recommendation. Reference to the Patient resource.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public immunizationRecommendationSearchR4(
    patient: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleImmunizationRecommendationR4>;
  public immunizationRecommendationSearchR4(
    patient: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleImmunizationRecommendationR4>>;
  public immunizationRecommendationSearchR4(
    patient: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleImmunizationRecommendationR4>>;
  public immunizationRecommendationSearchR4(
    patient: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (patient === null || patient === undefined) {
      throw new Error(
        'Required parameter patient was null or undefined when calling immunizationRecommendationSearchR4.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleImmunizationRecommendationR4>(
      'get',
      `${this.basePath}/R4/ImmunizationRecommendation`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param patient Reference to the Patient who was immunized.
   * @param date Vaccination administration date.
   * @param status &lt;p&gt;Status of the Immunization. Possible values are:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;completed&lt;/li&gt; &lt;li&gt;entered-in-error&lt;/li&gt; &lt;li&gt;not-done&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;*Note: incomplete Immunizations are not supported.&lt;/p&gt; &lt;p&gt; If no status is specified, all statuses are returned.&lt;/p&gt;
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public immunizationSearchR4(
    patient: string,
    date?: string,
    status?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleImmunizationR4>;
  public immunizationSearchR4(
    patient: string,
    date?: string,
    status?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleImmunizationR4>>;
  public immunizationSearchR4(
    patient: string,
    date?: string,
    status?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleImmunizationR4>>;
  public immunizationSearchR4(
    patient: string,
    date?: string,
    status?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (patient === null || patient === undefined) {
      throw new Error(
        'Required parameter patient was null or undefined when calling immunizationSearchR4.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (date !== undefined && date !== null) {
      queryParameters = queryParameters.set('date', <any>date);
    }
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }
    if (status !== undefined && status !== null) {
      queryParameters = queryParameters.set('status', <any>status);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleImmunizationR4>(
      'get',
      `${this.basePath}/R4/Immunization`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public locationSearchR4(
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleLocationR4>;
  public locationSearchR4(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleLocationR4>>;
  public locationSearchR4(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleLocationR4>>;
  public locationSearchR4(
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleLocationR4>(
      'get',
      `${this.basePath}/R4/Location`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public medicationSearchR4(
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleMedicationR4>;
  public medicationSearchR4(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleMedicationR4>>;
  public medicationSearchR4(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleMedicationR4>>;
  public medicationSearchR4(
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleMedicationR4>(
      'get',
      `${this.basePath}/R4/Medication`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param patient FHIR identifier for the patient whose nutrition order details are being requested.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public nutritionOrderSearchR4(
    patient: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleNutritionOrderR4>;
  public nutritionOrderSearchR4(
    patient: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleNutritionOrderR4>>;
  public nutritionOrderSearchR4(
    patient: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleNutritionOrderR4>>;
  public nutritionOrderSearchR4(
    patient: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (patient === null || patient === undefined) {
      throw new Error(
        'Required parameter patient was null or undefined when calling nutritionOrderSearchR4.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (patient !== undefined && patient !== null) {
      queryParameters = queryParameters.set('patient', <any>patient);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleNutritionOrderR4>(
      'get',
      `${this.basePath}/R4/NutritionOrder`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public organizationSearchR4(
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleOrganizationR4>;
  public organizationSearchR4(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleOrganizationR4>>;
  public organizationSearchR4(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleOrganizationR4>>;
  public organizationSearchR4(
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleOrganizationR4>(
      'get',
      `${this.basePath}/R4/Organization`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param address The patient&#x27;s street address.
   * @param addressCity The city for patient&#x27;s home address.
   * @param addressPostalcode The postal code for patient&#x27;s home address.
   * @param addressState The state for the patient&#x27;s home address.
   * @param birthdate The patient&#x27;s date of birth in the format YYYY-MM-DD.
   * @param family The patient&#x27;s family (last) name.
   * @param gender The patient&#x27;s legal sex. Starting in the August 2021 version of Epic, the legal-sex parameter is preferred.
   * @param given The patient&#x27;s given name. May include first and middle names.
   * @param identifier &lt;p&gt;The patient&#x27;s identifier.&lt;/p&gt;  &lt;p&gt;Starting in November 2018, this web service supports using ID and ID type combinations, such as Patient?identifier&#x3D;MRN|202497.&lt;/p&gt;
   * @param legalSex The patientâ€™s legal sex. Takes precedence over the gender search parameter. Available starting in the August 2021 version of Epic.
   * @param name Any part of the patient&#x27;s name. When discrete name parameters are used, such as family or given, this parameter is ignored.
   * @param ownName The patient&#x27;s own last name. Usually used in non-US names.
   * @param ownPrefix The patient&#x27;s own prefix. Usually used in non-US names.
   * @param partnerName The patient&#x27;s spouse&#x27;s last name. Usually used in non-US names.
   * @param partnerPrefix The patient&#x27;s spouse&#x27;s prefix. Usually used in non-US names.
   * @param telecom The patient&#x27;s phone number or email.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public patientSearchR4(
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    birthdate?: string,
    family?: string,
    gender?: string,
    given?: string,
    identifier?: string,
    legalSex?: string,
    name?: string,
    ownName?: string,
    ownPrefix?: string,
    partnerName?: string,
    partnerPrefix?: string,
    telecom?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundlePatientR4>;
  public patientSearchR4(
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    birthdate?: string,
    family?: string,
    gender?: string,
    given?: string,
    identifier?: string,
    legalSex?: string,
    name?: string,
    ownName?: string,
    ownPrefix?: string,
    partnerName?: string,
    partnerPrefix?: string,
    telecom?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundlePatientR4>>;
  public patientSearchR4(
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    birthdate?: string,
    family?: string,
    gender?: string,
    given?: string,
    identifier?: string,
    legalSex?: string,
    name?: string,
    ownName?: string,
    ownPrefix?: string,
    partnerName?: string,
    partnerPrefix?: string,
    telecom?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundlePatientR4>>;
  public patientSearchR4(
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    birthdate?: string,
    family?: string,
    gender?: string,
    given?: string,
    identifier?: string,
    legalSex?: string,
    name?: string,
    ownName?: string,
    ownPrefix?: string,
    partnerName?: string,
    partnerPrefix?: string,
    telecom?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (address !== undefined && address !== null) {
      queryParameters = queryParameters.set('address', <any>address);
    }
    if (addressCity !== undefined && addressCity !== null) {
      queryParameters = queryParameters.set('address-city', <any>addressCity);
    }
    if (addressPostalcode !== undefined && addressPostalcode !== null) {
      queryParameters = queryParameters.set(
        'address-postalcode',
        <any>addressPostalcode
      );
    }
    if (addressState !== undefined && addressState !== null) {
      queryParameters = queryParameters.set('address-state', <any>addressState);
    }
    if (birthdate !== undefined && birthdate !== null) {
      queryParameters = queryParameters.set('birthdate', <any>birthdate);
    }
    if (family !== undefined && family !== null) {
      queryParameters = queryParameters.set('family', <any>family);
    }
    if (gender !== undefined && gender !== null) {
      queryParameters = queryParameters.set('gender', <any>gender);
    }
    if (given !== undefined && given !== null) {
      queryParameters = queryParameters.set('given', <any>given);
    }
    if (identifier !== undefined && identifier !== null) {
      queryParameters = queryParameters.set('identifier', <any>identifier);
    }
    if (legalSex !== undefined && legalSex !== null) {
      queryParameters = queryParameters.set('legal-sex', <any>legalSex);
    }
    if (name !== undefined && name !== null) {
      queryParameters = queryParameters.set('name', <any>name);
    }
    if (ownName !== undefined && ownName !== null) {
      queryParameters = queryParameters.set('own-name', <any>ownName);
    }
    if (ownPrefix !== undefined && ownPrefix !== null) {
      queryParameters = queryParameters.set('own-prefix', <any>ownPrefix);
    }
    if (partnerName !== undefined && partnerName !== null) {
      queryParameters = queryParameters.set('partner-name', <any>partnerName);
    }
    if (partnerPrefix !== undefined && partnerPrefix !== null) {
      queryParameters = queryParameters.set(
        'partner-prefix',
        <any>partnerPrefix
      );
    }
    if (telecom !== undefined && telecom !== null) {
      queryParameters = queryParameters.set('telecom', <any>telecom);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundlePatientR4>(
      'get',
      `${this.basePath}/R4/Patient`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param email Value in an email contact.
   * @param identifier A practitioner&#x27;s identifier.
   * @param location Reference to one of the locations at which this practitioner provides care.
   * @param organization Reference to the organization that the practitioner represents or acts on behalf of.
   * @param phone A value in a phone contact.
   * @param practitioner A practitioner that can provide the defined services for the organization.
   * @param role The role a practitioner can perform at an organization.
   * @param specialty The practitioner&#x27;s specialty at an organization.
   * @param telecom The value in any kind of contact.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public practitionerRoleSearchR4(
    email?: string,
    identifier?: string,
    location?: string,
    organization?: string,
    phone?: string,
    practitioner?: string,
    role?: string,
    specialty?: string,
    telecom?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundlePractitionerRoleR4>;
  public practitionerRoleSearchR4(
    email?: string,
    identifier?: string,
    location?: string,
    organization?: string,
    phone?: string,
    practitioner?: string,
    role?: string,
    specialty?: string,
    telecom?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundlePractitionerRoleR4>>;
  public practitionerRoleSearchR4(
    email?: string,
    identifier?: string,
    location?: string,
    organization?: string,
    phone?: string,
    practitioner?: string,
    role?: string,
    specialty?: string,
    telecom?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundlePractitionerRoleR4>>;
  public practitionerRoleSearchR4(
    email?: string,
    identifier?: string,
    location?: string,
    organization?: string,
    phone?: string,
    practitioner?: string,
    role?: string,
    specialty?: string,
    telecom?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (email !== undefined && email !== null) {
      queryParameters = queryParameters.set('email', <any>email);
    }
    if (identifier !== undefined && identifier !== null) {
      queryParameters = queryParameters.set('identifier', <any>identifier);
    }
    if (location !== undefined && location !== null) {
      queryParameters = queryParameters.set('location', <any>location);
    }
    if (organization !== undefined && organization !== null) {
      queryParameters = queryParameters.set('organization', <any>organization);
    }
    if (phone !== undefined && phone !== null) {
      queryParameters = queryParameters.set('phone', <any>phone);
    }
    if (practitioner !== undefined && practitioner !== null) {
      queryParameters = queryParameters.set('practitioner', <any>practitioner);
    }
    if (role !== undefined && role !== null) {
      queryParameters = queryParameters.set('role', <any>role);
    }
    if (specialty !== undefined && specialty !== null) {
      queryParameters = queryParameters.set('specialty', <any>specialty);
    }
    if (telecom !== undefined && telecom !== null) {
      queryParameters = queryParameters.set('telecom', <any>telecom);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundlePractitionerRoleR4>(
      'get',
      `${this.basePath}/R4/PractitionerRole`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param family A portion of the family name. If name or identifier is provided, this is not required.
   * @param identifier A practitioner&#x27;s identifier, such as NPI. If Family or Name is provided, this is not required. This web service supports using ID and ID type combinations, such as Practitioner?identifier&#x3D;External|802559.
   * @param name Free text that can match either Family or Given (or both). If Family or Identifier is provided, this is not required.
   * @param address The free-text address.
   * @param addressCity The city specified in the address. City cannot be specified without state or ZIP code.
   * @param addressPostalcode A ZIP code specified in the address.
   * @param addressState A state specified in the address.
   * @param given A portion of the given name. If Given is provided, Family must also be provided.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public practitionerSearchR4(
    family: string,
    identifier: string,
    name: string,
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    given?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundlePractitionerR4>;
  public practitionerSearchR4(
    family: string,
    identifier: string,
    name: string,
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    given?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundlePractitionerR4>>;
  public practitionerSearchR4(
    family: string,
    identifier: string,
    name: string,
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    given?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundlePractitionerR4>>;
  public practitionerSearchR4(
    family: string,
    identifier: string,
    name: string,
    address?: string,
    addressCity?: string,
    addressPostalcode?: string,
    addressState?: string,
    given?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (family === null || family === undefined) {
      throw new Error(
        'Required parameter family was null or undefined when calling practitionerSearchR4.'
      );
    }

    if (identifier === null || identifier === undefined) {
      throw new Error(
        'Required parameter identifier was null or undefined when calling practitionerSearchR4.'
      );
    }

    if (name === null || name === undefined) {
      throw new Error(
        'Required parameter name was null or undefined when calling practitionerSearchR4.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (address !== undefined && address !== null) {
      queryParameters = queryParameters.set('address', <any>address);
    }
    if (addressCity !== undefined && addressCity !== null) {
      queryParameters = queryParameters.set('address-city', <any>addressCity);
    }
    if (addressPostalcode !== undefined && addressPostalcode !== null) {
      queryParameters = queryParameters.set(
        'address-postalcode',
        <any>addressPostalcode
      );
    }
    if (addressState !== undefined && addressState !== null) {
      queryParameters = queryParameters.set('address-state', <any>addressState);
    }
    if (family !== undefined && family !== null) {
      queryParameters = queryParameters.set('family', <any>family);
    }
    if (given !== undefined && given !== null) {
      queryParameters = queryParameters.set('given', <any>given);
    }
    if (identifier !== undefined && identifier !== null) {
      queryParameters = queryParameters.set('identifier', <any>identifier);
    }
    if (name !== undefined && name !== null) {
      queryParameters = queryParameters.set('name', <any>name);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundlePractitionerR4>(
      'get',
      `${this.basePath}/R4/Practitioner`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param identifier The study code.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public researchStudySearchR4(
    identifier: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleResearchStudyR4>;
  public researchStudySearchR4(
    identifier: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleResearchStudyR4>>;
  public researchStudySearchR4(
    identifier: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleResearchStudyR4>>;
  public researchStudySearchR4(
    identifier: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (identifier === null || identifier === undefined) {
      throw new Error(
        'Required parameter identifier was null or undefined when calling researchStudySearchR4.'
      );
    }

    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec(),
    });
    if (identifier !== undefined && identifier !== null) {
      queryParameters = queryParameters.set('identifier', <any>identifier);
    }

    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleResearchStudyR4>(
      'get',
      `${this.basePath}/R4/ResearchStudy`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public specimenSearchR4(
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleSpecimenR4>;
  public specimenSearchR4(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleSpecimenR4>>;
  public specimenSearchR4(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleSpecimenR4>>;
  public specimenSearchR4(
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleSpecimenR4>(
      'get',
      `${this.basePath}/R4/Specimen`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   *
   *
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public substanceSearchR4(
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<BundleSubstanceR4>;
  public substanceSearchR4(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<BundleSubstanceR4>>;
  public substanceSearchR4(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<BundleSubstanceR4>>;
  public substanceSearchR4(
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders;

    // authentication (bearer_auth) required
    if (
      this.configuration.apiKeys &&
      this.configuration.apiKeys['Authorization']
    ) {
      headers = headers.set(
        'Authorization',
        this.configuration.apiKeys['Authorization']
      );
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<BundleSubstanceR4>(
      'get',
      `${this.basePath}/R4/Substance`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }
}
